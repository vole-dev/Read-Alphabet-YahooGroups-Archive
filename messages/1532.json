{
  "userId": 326670551,
  "authorName": "Anthony Grahn",
  "from": "&quot;Anthony Grahn&quot; &lt;othermale@...&gt;",
  "profile": "othermale",
  "replyTo": "LIST",
  "senderId": "1flEa8nHWYsZ0FhhwXVUk9c83q30Rcvw7_WIOilMPanZGCUjyO4nKdewFy1cRiv0zd_y4Mfu_dxadszz5MIyZ1PpngLRZNmYHE4JiA",
  "spamInfo": {
    "isSpam": false,
    "reason": "6"
  },
  "subject": "Re: QS news update",
  "postDate": "1195386854",
  "msgId": 1532,
  "canDelete": false,
  "contentTrasformed": false,
  "systemMessage": false,
  "headers": {
    "messageIdInHeader": "PGZocDk1NitvcmZyQGVHcm91cHMuY29tPg==",
    "inReplyToHeader": "PDQ3M0ZEMzBCLjYwMzA2MDJAaWdsb3UuY29tPg=="
  },
  "prevInTopic": 1530,
  "nextInTopic": 1535,
  "prevInTime": 1531,
  "nextInTime": 1533,
  "topicId": 1434,
  "numMessagesInTopic": 69,
  "msgSnippet": "Missing some cases is bad but not horrible and the work invested to catch them yields diminishing returns compared to having the basic algorithm. Obviously",
  "messageBody": "<div id=\"ygrps-yiv-88930317\">Missing some cases is bad but not horrible and the work invested to<br/>\ncatch them yields diminishing returns compared to having the basic<br/>\nalgorithm. Obviously tacking an &quot;-e&quot; on the supposed root or<br/>\nun-doubling the last consonant before looking it up will catch a bunch.<br/>\n<br/>\nFalse positives like &quot;bed&quot; or &quot;ping&quot; are worse. I think it&#39;s safe to<br/>\nsay the root word must be more than 1 letter long; any suffix implying<br/>\notherwise can&#39;t be a suffix. <br/>\n<br/>\nThe basic algorithm can also be applied recursively to catch words<br/>\nlike &quot;swimmingly&quot; (obviously the double letter issue has to be<br/>\nresolved) but these are no longer quite the low hanging fruit that the<br/>\ninitial implementation was; maybe other tasks in other areas yield<br/>\nlarger benefits with less effort.<br/>\n<br/>\nAnyway, I think I&#39;m getting too deep in technicalities here and<br/>\ntrampling on important higher level discourse about QS. Do you mind if<br/>\nI communicate through your source forge email alias on such<br/>\nspecialized topics?<br/>\n<br/>\n<br/>\n<blockquote><span title=\"qreply\"> --- In <a rel=\"nofollow\" target=\"_blank\" href=\"mailto:Read_Alphabet@yahoogroups.com\">Read_Alphabet@yahoogroups.com</a>, Paul Tremblay &lt;phthenry@...&gt; wrote:<br/>\n&gt;<br/>\n&gt; Anthony Grahn wrote:<br/>\n&gt; &gt; <br/>\n&gt; <br/>\n&gt; &gt; <br/>\n&gt; &gt; This is an interesting proposal; I suppose the suggestion amounts<br/>\nto this:<br/>\n&gt; &gt; <br/>\n&gt; &gt; use #21Ing for:<br/>\n&gt; &gt; 1. the sounds of /N/ (this is the QM rule)<br/>\n&gt; &gt; 2. the sounds of Lexical Set KIT + /N/<br/>\n&gt; &gt; 3. the sounds of Lexical Set FLEECE + /N/<br/>\n&gt; &gt; <br/>\n&gt; &gt; I would also like to add:<br/>\n&gt; &gt; 4. the sound /N/+/g/<br/>\n&gt; &gt; <br/>\n&gt; &gt; I suggest #4 because 1.in practice most people will rarely distinguish<br/>\n&gt; &gt; &quot;finger&quot; and &quot;sing&quot; and 2. I know of no case where it is necessary to<br/>\n&gt; &gt; indicate that difference in writing and 3. the /Nk/ is more obvious<br/>\n&gt; &gt; and less error prone than /N/+/g/ and can be still be written as<br/>\nIng+Key<br/>\n&gt; &gt; <br/>\n&gt; <br/>\n&gt; Okay, so I&#39;ve followed this rule as so:<br/>\n&gt; <br/>\n&gt; 1. Find out if the QS word ends in &#39;iN&#39; or &#39;IN&#39; or &#39;Ng&#39;<br/>\n&gt; <br/>\n&gt; 2. If 1 is true, check for the root word in TO. So for the word <br/>\n&gt; absorbing (abzYrbiN), knock of the ing, and see if the root exits. It <br/>\n&gt; does, so go with the QS word abzYrbN<br/>\n&gt; <br/>\n&gt; 3. If 2 is false, check to see for the root word in QS. So for the word<br/>\n&gt; (abrogating) AbragEtiN, if I knock off the &quot;ing&quot; in the TO word, I come <br/>\n&gt; up with &quot;abrogat,&quot; not a word. But if I knock off &quot;iN&quot; from the QS<br/>\nword, <br/>\n&gt; I come up with the QS word &quot;AbragEt,&quot; which exists. So change AbragEtiN <br/>\n&gt; to AbragEtN<br/>\n&gt; <br/>\n&gt; 4. No root if found in either QS or TO, so don&#39;t change the word. This <br/>\n&gt; leads to some errors. For example, the word &quot;advocating&quot; (AdvakEtiN)<br/>\nhas <br/>\n&gt; neither a TO or a QS root, because if you take off the &quot;ing,&quot; you get <br/>\n&gt; &quot;advoat,&quot; and if you take off the &quot;iN&quot; you get &quot;AdvakEt,&quot; but the root <br/>\n&gt; word in QS is pronounced &quot;Advakat,&quot; so there is no match.<br/>\n&gt; <br/>\n&gt; I followed the same rules for words ending in &quot;ed&quot; or &quot;ad.&quot;<br/>\n&gt; <br/>\n&gt; This algorithm will give me an error with the word &quot;bed.&quot; It will look <br/>\n&gt; for the TO root of &quot;b&quot; and find the letter b. In order to handle this I <br/>\n&gt; need to explain that I am using this algorithm to generate a CMU <br/>\n&gt; dictionary. Another dict of checked words will always override this <br/>\n&gt; dictionary, so I need to put &quot;bed bed&quot; (TO and QS the same in this<br/>\ncase) <br/>\n&gt; in the checked words dict. The algorithm will only be run when creating <br/>\n&gt; a CMU dictionary, maybe only once, maybe several more times if we<br/>\ndevise <br/>\n&gt; more clever ways to convert the bulk of English words.<br/>\n&gt; <br/>\n&gt; Paul<br/>\n&gt; </span></blockquote></div>",
  "specialLinks": [],
  "rawEmail": "Return-Path: &lt;othermale@...&gt;\r\nX-Sender: othermale@...\r\nX-Apparently-To: Read_Alphabet@yahoogroups.com\r\nX-Received: (qmail 82825 invoked from network); 18 Nov 2007 11:54:17 -0000\r\nX-Received: from unknown (66.218.67.97)\n  by m56.grp.scd.yahoo.com with QMQP; 18 Nov 2007 11:54:17 -0000\r\nX-Received: from unknown (HELO n11d.bullet.scd.yahoo.com) (66.218.67.60)\n  by mta18.grp.scd.yahoo.com with SMTP; 18 Nov 2007 11:54:17 -0000\r\nX-Received: from [66.218.69.4] by n22.bullet.scd.yahoo.com with NNFMP; 18 Nov 2007 11:54:16 -0000\r\nX-Received: from [66.218.66.85] by t4.bullet.scd.yahoo.com with NNFMP; 18 Nov 2007 11:54:16 -0000\r\nDate: Sun, 18 Nov 2007 11:54:14 -0000\r\nTo: Read_Alphabet@yahoogroups.com\r\nMessage-ID: &lt;fhp956+orfr@...&gt;\r\nIn-Reply-To: &lt;473FD30B.6030602@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;Anthony Grahn&quot; &lt;othermale@...&gt;\r\nSubject: Re: QS news update\r\nX-Yahoo-Group-Post: member; u=326670551; y=LunVa3a1F4SiHhqkAjw18yAygU3sjGtkSG6HRyaQByTfj5Ub\r\nX-Yahoo-Profile: othermale\r\n\r\nMissing some cases is bad but not horrible and the work invested to\ncatch t=\r\nhem yields diminishing returns compared to having the basic\nalgorithm. Obvi=\r\nously tacking an &quot;-e&quot; on the supposed root or\nun-doubling the last consonan=\r\nt before looking it up will catch a bunch.\n\nFalse positives like &quot;bed&quot; or &quot;=\r\nping&quot; are worse. I think it&#39;s safe to\nsay the root word must be more than 1=\r\n letter long; any suffix implying\notherwise can&#39;t be a suffix. \n\nThe basic =\r\nalgorithm can also be applied recursively to catch words\nlike &quot;swimmingly&quot; =\r\n(obviously the double letter issue has to be\nresolved) but these are no lon=\r\nger quite the low hanging fruit that the\ninitial implementation was; maybe =\r\nother tasks in other areas yield\nlarger benefits with less effort.\n\nAnyway,=\r\n I think I&#39;m getting too deep in technicalities here and\ntrampling on impor=\r\ntant higher level discourse about QS. Do you mind if\nI communicate through =\r\nyour source forge email alias on such\nspecialized topics?\n\n\n--- In Read_Alp=\r\nhabet@yahoogroups.com, Paul Tremblay &lt;phthenry@...&gt; wrote:\n&gt;\n&gt; Anthony Grah=\r\nn wrote:\n&gt; &gt; \n&gt; \n&gt; &gt; \n&gt; &gt; This is an interesting proposal; I suppose the su=\r\nggestion amounts\nto this:\n&gt; &gt; \n&gt; &gt; use #21Ing for:\n&gt; &gt; 1. the sounds of /N/=\r\n (this is the QM rule)\n&gt; &gt; 2. the sounds of Lexical Set KIT + /N/\n&gt; &gt; 3. th=\r\ne sounds of Lexical Set FLEECE + /N/\n&gt; &gt; \n&gt; &gt; I would also like to add:\n&gt; &gt;=\r\n 4. the sound /N/+/g/\n&gt; &gt; \n&gt; &gt; I suggest #4 because 1.in practice most peop=\r\nle will rarely distinguish\n&gt; &gt; &quot;finger&quot; and &quot;sing&quot; and 2. I know of no case=\r\n where it is necessary to\n&gt; &gt; indicate that difference in writing and 3. th=\r\ne /Nk/ is more obvious\n&gt; &gt; and less error prone than /N/+/g/ and can be sti=\r\nll be written as\nIng+Key\n&gt; &gt; \n&gt; \n&gt; Okay, so I&#39;ve followed this rule as so:\n=\r\n&gt; \n&gt; 1. Find out if the QS word ends in &#39;iN&#39; or &#39;IN&#39; or &#39;Ng&#39;\n&gt; \n&gt; 2. If 1 i=\r\ns true, check for the root word in TO. So for the word \n&gt; absorbing (abzYrb=\r\niN), knock of the ing, and see if the root exits. It \n&gt; does, so go with th=\r\ne QS word abzYrbN\n&gt; \n&gt; 3. If 2 is false, check to see for the root word in =\r\nQS. So for the word\n&gt; (abrogating) AbragEtiN, if I knock off the &quot;ing&quot; in t=\r\nhe TO word, I come \n&gt; up with &quot;abrogat,&quot; not a word. But if I knock off &quot;iN=\r\n&quot; from the QS\nword, \n&gt; I come up with the QS word &quot;AbragEt,&quot; which exists. =\r\nSo change AbragEtiN \n&gt; to AbragEtN\n&gt; \n&gt; 4. No root if found in either QS or=\r\n TO, so don&#39;t change the word. This \n&gt; leads to some errors. For example, t=\r\nhe word &quot;advocating&quot; (AdvakEtiN)\nhas \n&gt; neither a TO or a QS root, because =\r\nif you take off the &quot;ing,&quot; you get \n&gt; &quot;advoat,&quot; and if you take off the &quot;iN=\r\n&quot; you get &quot;AdvakEt,&quot; but the root \n&gt; word in QS is pronounced &quot;Advakat,&quot; so=\r\n there is no match.\n&gt; \n&gt; I followed the same rules for words ending in &quot;ed&quot;=\r\n or &quot;ad.&quot;\n&gt; \n&gt; This algorithm will give me an error with the word &quot;bed.&quot; It=\r\n will look \n&gt; for the TO root of &quot;b&quot; and find the letter b. In order to han=\r\ndle this I \n&gt; need to explain that I am using this algorithm to generate a =\r\nCMU \n&gt; dictionary. Another dict of checked words will always override this =\r\n\n&gt; dictionary, so I need to put &quot;bed bed&quot; (TO and QS the same in this\ncase)=\r\n \n&gt; in the checked words dict. The algorithm will only be run when creating=\r\n \n&gt; a CMU dictionary, maybe only once, maybe several more times if we\ndevis=\r\ne \n&gt; more clever ways to convert the bulk of English words.\n&gt; \n&gt; Paul\n&gt;\n\n\n\n"
}